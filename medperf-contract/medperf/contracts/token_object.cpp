/* Copyright 2024 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <string>
#include <vector>
// #include <sstream>
#include <stddef.h>
#include <stdint.h>
#include <algorithm>
#include "Dispatch.h"

#include "Cryptography.h"
#include "KeyValue.h"
#include "Environment.h"
#include "Message.h"
#include "Response.h"
#include "Types.h"
#include "Util.h"
#include "Value.h"
#include "WasmExtensions.h"

#include "contract/attestation.h"
#include "contract/base.h"
#include "exchange/token_object.h"
#include "medperf/token_object.h"


static KeyValueStore dataset_TO_store("dataset_TO_store");
static const std::string dataset_id_KEY("dataset_id");
static const std::string experiment_id_KEY("experiment_id");
static const std::string associated_model_ids_KEY("associated_model_ids");
static const std::string associated_model_tags_KEY("associated_model_tags");
static const std::string dataset_max_use_count_KEY("dataset_max_use_count");
static const std::string dataset_current_use_count_KEY("dataset_current_use_count");
static const std::string pdo_challenge_KEY("pdo_challenge");

static const std::string dataset_use_capability_kv_store_encryption_key_KEY("dataset_use_capability_kv_store_encryption_key");
static const std::string dataset_use_capability_kv_store_root_block_hash_KEY("dataset_use_capability_kv_store_root_block_hash");
static const std::string dataset_use_capability_kv_store_input_key_KEY("dataset_use_capability_kv_store_input_key");

//

// -----------------------------------------------------------------
// METHOD: initialize
//
// 1. Store the dataset_id (hash of the dataset) that is tokenized. This information should be generated by the dataset owner. The dataset_id is not cross-checked with the dataset itself for now.
// 2. For testing purposes, the experiment_id is associated with the dataset_token at this step, which implies that the dataset is by default consent to be inferenced by all the models under the associated experiment.
//    We will Initilize the token object with no experiment/model association. The association will be done via an additional association method.
// 3. The model_id are also stored in the token object. The model_id is the path to the modelcubes. (So far we assume all model matierials are stored locally)
//
//   Note that the token object is intentionally kept generic and not hard-coded to any specific model.
// -------------------------------------------------------------------------------------------------------------
bool ww::medperf::token_object::initialize(const Message &msg, const Environment &env, Response &rsp)
{
    ASSERT_SENDER_IS_CREATOR(env, rsp);
    ASSERT_UNINITIALIZED(rsp);

    // print the message to the log
    

    ASSERT_SUCCESS(rsp, msg.validate_schema(DATASET_TO_INIT_PARAM_SCHEMA),
                   "invalid request, missing required parameters for medperf dataset token object initialization");

    // Get the params to be stored in dataset_TO_store
    const std::string dataset_id_value(msg.get_string("dataset_id"));

    // Store params from msg in dataset_TO_store
    ASSERT_SUCCESS(rsp, dataset_TO_store.set(dataset_id_KEY, dataset_id_value), "failed to store dataset_id");
    // ASSERT_SUCCESS(rsp, dataset_TO_store.set(experiment_id_KEY, "none"), "failed to store experiment_id");
    // ASSERT_SUCCESS(rsp, dataset_TO_store.set(associated_model_ids_KEY, "none"), "failed to store associated_model_ids");
    // ASSERT_SUCCESS(rsp, dataset_TO_store.set(dataset_max_use_count_KEY, 0), "failed to store dataset_max_use_count");

    // Set current use count to 0
    ASSERT_SUCCESS(rsp, dataset_TO_store.set(dataset_current_use_count_KEY, (uint32_t)0), "failed to store dataset_current_use_count");

    // Do the rest of the initialization of the token object via the initialize method in the exchange contract
    ww::value::Structure to_message(TO_INITIALIZE_PARAM_SCHEMA);

    const std::string ledger_verifying_key(msg.get_string("ledger_verifying_key"));
    ww::value::Object initialization_package;
    msg.get_value("initialization_package", initialization_package);
    ww::value::Object asset_authority_chain;
    msg.get_value("asset_authority_chain", asset_authority_chain);

    ASSERT_SUCCESS(rsp, to_message.set_string("ledger_verifying_key", ledger_verifying_key.c_str()), "unexpected error: failed to set the parameter");
    ASSERT_SUCCESS(rsp, to_message.set_value("initialization_package", initialization_package), "unexpected error: failed to set the parameter");
    ASSERT_SUCCESS(rsp, to_message.set_value("asset_authority_chain", asset_authority_chain), "unexpected error: failed to set the parameter");

    return ww::exchange::token_object::initialize(to_message, env, rsp);
}


// update_policy attaches the policy 
// bool ww::medperf::token_object::update_policy(const Message &msg, const Environment &env, Response &rsp)
// {
//     // only the owner can 
//     ASSERT_SENDER_IS_CREATOR(env, rsp);
//     ASSERT_UNINITIALIZED(rsp);
// }

// -----------------------------------------------------------------
// METHOD: get_dataset_info
//
// Return fixed model parameters, schema for user-specified model parameters, and
// model metadata useful for the TO to understand how to use the model required to invoke Inference API.
// Method is public, and can be invoked by PDO user.
// note that we are not returning the "remaining use count" as part of the model info.
// ideally a prospective token buyer would like access to "remaining use count" before purchasing the token.
// In such a case, ideally such information shall be provided only after escrow of payment for the token is done.
// Left for future enhancement.
// -----------------------------------------------------------------

bool ww::medperf::token_object::get_dataset_info(
    const Message &msg,
    const Environment &env,
    Response &rsp)
{
    ASSERT_INITIALIZED(rsp);
    // ww::value::Structure v(DATASET_INFO_SCHEMA);
    ww::value::Object v;

    // Get the dataset_id
    std::string dataset_id_string;
    ASSERT_SUCCESS(rsp, dataset_TO_store.get(dataset_id_KEY, dataset_id_string), "failed to retrieve dataset_id");
    ASSERT_SUCCESS(rsp, v.set_string("dataset_id", dataset_id_string.c_str()), "failed to set return value for dataset_id");


    std::string associated_model_ids_string;
    ASSERT_SUCCESS(rsp, dataset_TO_store.get(associated_model_ids_KEY, associated_model_ids_string), "failed to retrieve associated_model_ids");
    ASSERT_SUCCESS(rsp, v.set_string("associated_model_ids", associated_model_ids_string.c_str()), "failed to set return value for associated_model_ids");


    std::string experiment_id_string;
    ASSERT_SUCCESS(rsp, dataset_TO_store.get(experiment_id_KEY, experiment_id_string), "failed to retrieve experiment_id_string");
    ASSERT_SUCCESS(rsp, v.set_string("experiment_id", experiment_id_string.c_str()), "failed to set return value for experiment_id_string");

    std::string associated_model_tags_string;
    ASSERT_SUCCESS(rsp, dataset_TO_store.get(associated_model_tags_KEY, associated_model_tags_string), "failed to retrieve associated_model_tags");
    ASSERT_SUCCESS(rsp, v.set_string("associated_model_tags", associated_model_tags_string.c_str()), "failed to set return value for associated_model_tags");

    // Get the max use count
    uint32_t dataset_max_use_count_value;
    ASSERT_SUCCESS(rsp, dataset_TO_store.get(dataset_max_use_count_KEY, dataset_max_use_count_value), "failed to retrieve dataset_max_use_count");
    ASSERT_SUCCESS(rsp, v.set_number("max_use_count", dataset_max_use_count_value), "failed to set return value for max_use_count");

    return rsp.value(v, false);
}

// -----------------------------------------------------------------
// METHOD: use_dataset
//
// 1.  Save the parameters required to generate a use_dataset capability to kvs, increments the current use count, and returns the call
//     Capability is calculated and returned once proof of commit of state is presented (via the get_capability method).
// 2. Inputs:
//        kvstore_encryption_key
//        kvstore_root_block_hash
//        kvstore_input_key
//        model_ids_to_evaluate
// The first 3 parameters provide flexibility to use large inputs for the model via the kv_store attached to the guardian.
// Only TO may invoke method
// -----------------------------------------------------------------
bool ww::medperf::token_object::use_dataset(
    const Message &msg,
    const Environment &env,
    Response &rsp)
{
    ASSERT_SENDER_IS_OWNER(env, rsp);
    ASSERT_INITIALIZED(rsp);

    ASSERT_SUCCESS(rsp, msg.validate_schema(USE_DATASET_SCHEMA), "invalid request, missing required parameters");

    const std::string dataset_id(msg.get_string("dataset_id"));
    std::string dataset_id_store;
    ASSERT_SUCCESS(rsp, dataset_TO_store.get(dataset_id_KEY, dataset_id_store), "fail to retrieve dataset_id");
    ASSERT_SUCCESS(rsp, dataset_id == dataset_id_store, "dataset does not exist");

    const std::string kvstore_encryption_key(msg.get_string("kvstore_encryption_key"));
    const std::string kvstore_root_block_hash(msg.get_string("kvstore_root_block_hash"));
    const std::string kvstore_input_key(msg.get_string("kvstore_input_key"));

    
    std::string associated_model_ids_string;
    ASSERT_SUCCESS(rsp, dataset_TO_store.get(associated_model_ids_KEY, associated_model_ids_string), "failed to retrieve associated_model_ids");
    uint32_t associated_model_ids = std::stoi(associated_model_ids_string);
    
    std::string model_ids_to_evaluate_string(msg.get_string("model_ids_to_evaluate"));
    const uint32_t model_ids_to_evaluate = std::stoi(model_ids_to_evaluate_string) - 1;
    ASSERT_SUCCESS(rsp, model_ids_to_evaluate < associated_model_ids, "model is not associated with the dataset");

    std::string associated_model_tags_string;
    ASSERT_SUCCESS(rsp, dataset_TO_store.get(associated_model_tags_KEY, associated_model_tags_string), "failed to retrieve associated_model_tags");
    ww::types::StringArray associated_model_tags_vec(associated_model_tags_string);
    ASSERT_SUCCESS(rsp, associated_model_tags_vec[model_ids_to_evaluate] == '0', "model has already been scheduled or used"); 
                                                                          
    uint32_t dataset_current_use_count_value;
    uint32_t dataset_max_use_count_value;
    ASSERT_SUCCESS(rsp, dataset_TO_store.get(dataset_current_use_count_KEY, dataset_current_use_count_value), "failed to retrieve dataset_current_use_count");
    ASSERT_SUCCESS(rsp, dataset_TO_store.get(dataset_max_use_count_KEY, dataset_max_use_count_value), "failed to retrieve dataset_max_use_count");
    ASSERT_SUCCESS(rsp, dataset_current_use_count_value + 1 <= dataset_max_use_count_value, "max use count is reached, cannot use dataset");

    // '1' represents that the model is scheduled for evaluation
    associated_model_tags_vec[model_ids_to_evaluate] = '1';
    ASSERT_SUCCESS(rsp, dataset_TO_store.set(associated_model_tags_KEY, associated_model_tags_vec.str().c_str()), "failed to update associated_model_tags");
    ASSERT_SUCCESS(rsp, dataset_TO_store.set(dataset_current_use_count_KEY, dataset_current_use_count_value + 1), "failed to update dataset_current_use_count");
    
    // ww::types::StringArray model_ids_to_evaluate_vec(model_ids_to_evaluate);
    // uint32_t num_models_to_evaluate = std::count(model_ids_to_evaluate_vec.begin(), model_ids_to_evaluate_vec.end(), ',') + 1;

    // ASSERT_SUCCESS(rsp, num_models_to_evaluate > 0, "invalid request, no models to evaluate");

    // std::string associated_model_ids_string;
    // ASSERT_SUCCESS(rsp, dataset_TO_store.get(associated_model_ids_KEY, associated_model_ids_string), "failed to retrieve associated_model_ids");
    // ww::types::StringArray associated_model_ids_vec(associated_model_ids_string);
    // uint32_t num_associated_models = std::count(associated_model_ids_vec.begin(), associated_model_ids_vec.end(), ',') + 1;

    // std::vector<std::string> associated_models = stringToVector(associated_model_ids_string);
    // std::vector<std::string> to_evaluate_models = stringToVector(model_ids_to_evaluate);
    // std::vector<uint32_t> model_index;
    // std::string error_message;
    // for (std::string to_eva_model_id : to_evaluate_models)
    // {
    //     error_message = to_eva_model_id + " not associated with the dataset";
    //     ASSERT_SUCCESS(rsp, std::find(associated_models.begin(), associated_models.end(), to_eva_model_id) != associated_models.end(), error_message.c_str());
    //     model_index.push_back(std::find(associated_models.begin(), associated_models.end(), to_eva_model_id) - associated_models.begin());
    // }

    
    // uint32_t dataset_current_use_count_value;
    // uint32_t dataset_max_use_count_value;
    // ASSERT_SUCCESS(rsp, dataset_TO_store.get(dataset_current_use_count_KEY, dataset_current_use_count_value), "failed to retrieve dataset_current_use_count");
    // ASSERT_SUCCESS(rsp, dataset_TO_store.get(dataset_max_use_count_KEY, dataset_max_use_count_value), "failed to retrieve dataset_max_use_count");
    // ASSERT_SUCCESS(rsp, dataset_current_use_count_value + num_models_to_evaluate <= dataset_max_use_count_value, "max use count is reached, cannot use dataset");
    
    // // Add the counter if the use_dataset is successful
    // ASSERT_SUCCESS(rsp, dataset_TO_store.set(dataset_current_use_count_KEY, dataset_current_use_count_value + num_models_to_evaluate), "failed to update dataset_current_use_count");

    // // change the status of the model_ids to "scheduled"
    // // const std::string associated_model_ids_to_be_stored = associated_model_ids_json.dump();
    // const std::string associated_model_ids_to_be_stored = mapToString(associated_model_ids_map);
    // ASSERT_SUCCESS(rsp, dataset_TO_store.set(associated_model_ids_KEY, associated_model_ids_to_be_stored), "failed to store associated_model_ids");

    // store the parameters required to generate a use_dataset capability
    ASSERT_SUCCESS(rsp, dataset_TO_store.set(dataset_use_capability_kv_store_encryption_key_KEY, kvstore_encryption_key), "failed to store dataset_use_capability_kv_store_enc_key");
    ASSERT_SUCCESS(rsp, dataset_TO_store.set(dataset_use_capability_kv_store_root_block_hash_KEY, kvstore_root_block_hash), "failed to store dataset_use_capability_kv_store_hash");
    ASSERT_SUCCESS(rsp, dataset_TO_store.set(dataset_use_capability_kv_store_input_key_KEY, kvstore_input_key), "failed to store dataset_use_capability_kv_store_input_key");
    // ASSERT_SUCCESS(rsp, dataset_TO_store.set(dataset_use_capability_user_inputs_KEY, user_inputs), "failed to store dataset_use_capability_user_inputs");

    return rsp.success(true);
}




// -----------------------------------------------------------------
// METHOD: get_capability
//
// Check proof of commit, calculate/return capability.
// Only TO may invoke method. It is currently possible for the TO to ask for a past capability
// even after token transfer. This is a feature, not a bug. The justification is that
// any new owner is only getting access to "unused uses" of the model.
// -----------------------------------------------------------------

bool ww::medperf::token_object::get_capability(
    const Message &msg,
    const Environment &env,
    Response &rsp)
{
    ASSERT_SENDER_IS_OWNER(env, rsp);
    ASSERT_INITIALIZED(rsp);
    ASSERT_SUCCESS(rsp, msg.validate_schema(GET_CAPABILITY_SCHEMA), "invalid request, missing required parameters");

    // Ensure that the current use count is greater than 0, so that an attempt to use the model was made.
    // Otherwise, the capability cannot be generated.ls
    // uint32_t dataset_current_use_count_value;
    // ASSERT_SUCCESS(rsp, dataset_TO_store.get(dataset_current_use_count_KEY, dataset_current_use_count_value), "failed to retrieve dataset_current_use_count");
    // ASSERT_SUCCESS(rsp, dataset_current_use_count_value > 0, "invalid request, capability can be obtained only after use_dataset is called");

    // check for proof of commit of current state of the token object before returning capability
    std::string ledger_key;
    if (!ww::contract::attestation::get_ledger_key(ledger_key) && ledger_key.length() > 0)
        return rsp.error("contract has not been initialized");

    const std::string ledger_signature(msg.get_string("ledger_signature"));

    ww::types::ByteArray buffer;
    std::copy(env.contract_id_.begin(), env.contract_id_.end(), std::back_inserter(buffer));
    std::copy(env.state_hash_.begin(), env.state_hash_.end(), std::back_inserter(buffer));

    ww::types::ByteArray signature;
    if (!ww::crypto::b64_decode(ledger_signature, signature))
        return rsp.error("failed to decode ledger signature");
    if (!ww::crypto::ecdsa::verify_signature(buffer, ledger_key, signature))
        return rsp.error("failed to verify ledger signature");

    // the current state has been committed so now compute and return the capability
    ww::value::Structure params(GENERATE_CAPABILITY_SCHEMA);

    // Get kvstore_encryption_key from dataset_TO_store
    std::string kvstore_encryption_key;
    ASSERT_SUCCESS(rsp, dataset_TO_store.get(dataset_use_capability_kv_store_encryption_key_KEY, kvstore_encryption_key), "failed to retrieve dataset_use_capability_kv_store_enc_key");
    ASSERT_SUCCESS(rsp, params.set_string("kvstore_encryption_key", kvstore_encryption_key.c_str()), "failed to set return value for kvstore_encryption_key");

    // Get kvstore_root_block_hash from dataset_TO_store
    std::string kvstore_root_block_hash;
    ASSERT_SUCCESS(rsp, dataset_TO_store.get(dataset_use_capability_kv_store_root_block_hash_KEY, kvstore_root_block_hash), "failed to retrieve dataset_use_capability_kv_store_hash");
    ASSERT_SUCCESS(rsp, params.set_string("kvstore_root_block_hash", kvstore_root_block_hash.c_str()), "failed to set return value for kvstore_root_block_hash");

    // Get kvstore_input_key from dataset_TO_store
    std::string kvstore_input_key;
    ASSERT_SUCCESS(rsp, dataset_TO_store.get(dataset_use_capability_kv_store_input_key_KEY, kvstore_input_key), "failed to retrieve dataset_use_capability_kv_store_input_key");
    ASSERT_SUCCESS(rsp, params.set_string("kvstore_input_key", kvstore_input_key.c_str()), "failed to set return value for kvstore_input_key");

    // Get dataset_id from dataset_TO_store
    std::string dataset_id_store;
    ASSERT_SUCCESS(rsp, dataset_TO_store.get(dataset_id_KEY, dataset_id_store), "failed to retrieve dataset_id");
    std::string dataset_id_order(msg.get_string("dataset_id"));
    ASSERT_SUCCESS(rsp, dataset_id_store == dataset_id_order, "dataset does not exist");
    ASSERT_SUCCESS(rsp, params.set_string("dataset_id", dataset_id_store.c_str()), "failed to set return value for dataset_id");

    // Get associated_model_ids from dataset_TO_store
    std::string associated_model_tags_string;
    ASSERT_SUCCESS(rsp, dataset_TO_store.get(associated_model_tags_KEY, associated_model_tags_string), "failed to retrieve associated_model_tags");
    ww::types::StringArray associated_model_tags_vec(associated_model_tags_string);
    std::string model_id_to_evaluate_string = "";

    for (size_t i = 0; i < associated_model_tags_vec.size(); i++)
    {
        if (associated_model_tags_vec[i] == '1')
        {
            model_id_to_evaluate_string += std::to_string(i+1) + ",";
            associated_model_tags_vec[i] = '2';
        
        }
    }
    model_id_to_evaluate_string.pop_back();

    ASSERT_SUCCESS(rsp, dataset_TO_store.set(associated_model_tags_KEY, associated_model_tags_vec.str().c_str()), "failed to store associated_model_ids");
    ASSERT_SUCCESS(rsp, params.set_string("model_ids_to_evaluate", model_id_to_evaluate_string.c_str()), "failed to set return value for model_ids_to_evaluate");


    // Calculate capability
    ww::value::Object result;
    ASSERT_SUCCESS(rsp, ww::exchange::token_object::create_operation_package("use_dataset", params, result),
                   "unexpected error: failed to generate capability");

    // this assumes that generating the capability changes state
    return rsp.value(result, true);
}

// -----------------------------------------------------------------
// Method: return a hello world message
// -----------------------------------------------------------------

bool ww::medperf::token_object::owner_test(
    const Message &msg,
    const Environment &env,
    Response &rsp)
{
    // check if this is called by the owner
    ASSERT_SENDER_IS_OWNER(env, rsp);
    ww::value::String result("owner!");
    return rsp.value(result, false);
}

// -----------------------------------------------------------------
// Method: check if the sender is the creator
// -----------------------------------------------------------------

bool ww::medperf::token_object::update_policy(
    const Message &msg,
    const Environment &env,
    Response &rsp)
{
    // check if this is called by the creator
    ASSERT_SENDER_IS_CREATOR(env, rsp);

    // schema validation
    ASSERT_SUCCESS(rsp, msg.validate_schema(UPDATE_POLICY_SCHEMA), "invalid request, missing required parameters");

    ww::value::Structure result(DATASET_INFO_SCHEMA);


    const std::string dataset_id_value(msg.get_string("dataset_id"));
    std::string dataset_id_value_from_store;
    ASSERT_SUCCESS(rsp, dataset_TO_store.get(dataset_id_KEY, dataset_id_value_from_store), "failed to retrieve dataset_id");
    ASSERT_SUCCESS(rsp, dataset_id_value_from_store == dataset_id_value, "dataset does not exist");
    ASSERT_SUCCESS(rsp, result.set_string("dataset_id", dataset_id_value.c_str()), "failed to set return value for dataset_id");

    std::string experiment_id_value(msg.get_string("experiment_id"));
    // ASSERT_SUCCESS(rsp, msg.get_string("experiment_id", experiment_id_value), "failed to retrieve experiment_id");
    ASSERT_SUCCESS(rsp, dataset_TO_store.set(experiment_id_KEY, experiment_id_value), "failed to store experiment_id");
    ASSERT_SUCCESS(rsp, result.set_string("experiment_id", experiment_id_value.c_str()), "failed to set return value for experiment_id");

    const std::string associated_model_ids_value(msg.get_string("associated_model_ids"));
    ASSERT_SUCCESS(rsp, dataset_TO_store.set(associated_model_ids_KEY, associated_model_ids_value), "failed to store associated_model_ids");
    ASSERT_SUCCESS(rsp, result.set_string("associated_model_ids", associated_model_ids_value.c_str()), "failed to set return value for associated_model_ids");
    
    // size_t model_count;
    // ww::types::StringArray associated_model_ids_for_tag_string(associated_model_ids_value);
    // model_count = std::count(associated_model_ids_for_tag_string.begin(), associated_model_ids_for_tag_string.end(), ',') + 1; 

    size_t model_count = std::stoi(associated_model_ids_value);
    const std::string associated_model_tags_value(model_count, '0');
    ASSERT_SUCCESS(rsp, dataset_TO_store.set(associated_model_tags_KEY, associated_model_tags_value.c_str()), "failed to store associated_model_tags");
    ASSERT_SUCCESS(rsp, result.set_string("associated_model_tags", associated_model_tags_value.c_str()), "failed to set return value for associated_model_tags");
    // ww::value::Array associated_model_ids_array = splitString(associated_model_ids_value.c_str(), ',');
    

    // std::vector<std::string> associated_model_vec = stringToVector(associated_model_ids_value);
    // set the associated_model_tag for each model_id in associated_model_ids to '0'
    // std::vector<std::string> associated_model_tags_vec(associated_model_vec.size(), '0');
    // const std::string associated_model_tags_value = vectorToString(associated_model_tags_vec);
    // ASSERT_SUCCESS(rsp, dataset_TO_store.set(associated_model_tags_KEY, associated_model_tags_value), "failed to store associated_model_tags");

    // removed for testing
    // =============================================
    // std::vector<std::string> associated_model_ids = stringToVector(associated_model_ids_value);
    // std::map<std::string, std::string> associated_model_ids_map;
    // for (auto model_id : associated_model_ids)
    // {
    //     associated_model_ids_map[model_id] = "not used";
    // }
    // const std::string associated_model_to_be_stored = mapToString(associated_model_ids_map);
    // ASSERT_SUCCESS(rsp, dataset_TO_store.set(associated_model_ids_KEY, associated_model_to_be_stored), "failed to store associated_model_ids");

    const uint32_t dataset_max_use_count_value = (uint32_t)msg.get_number("max_use_count");
    ASSERT_SUCCESS(rsp, dataset_TO_store.set(dataset_max_use_count_KEY, dataset_max_use_count_value), "failed to store dataset_max_use_count");
    ASSERT_SUCCESS(rsp, result.set_number("max_use_count", dataset_max_use_count_value), "failed to set return value for max_use_count");
    // ww::value::String result("Policy updated!");

    return rsp.value(result, true);
    // return rsp.success(true);
}



std::string mapToString(const std::map<std::string, std::string>& myMap) {
    std::ostringstream oss;  // Create a string stream
    oss << "{";
    for (auto it = myMap.begin(); it != myMap.end(); ++it) {
        oss << "\"" << it->first << "\": \"" << it->second << "\"";
        if (std::next(it) != myMap.end()) {
            oss << ", "; // Add a comma, except for the last item
        }
    }
    oss << "}";
    return oss.str(); // Return the formatted string
}

std::map<std::string, std::string> stringToMap(const std::string& str) {
    std::map<std::string, std::string> myMap;
    size_t start = 0;
    size_t end = 0;

    // Check if the string starts with '{' and ends with '}'
    if (str.front() == '{' && str.back() == '}') {
        start = 1;  // Skip '{'
        end = str.size() - 1;  // Calculate end position
    } else {
        return myMap; // Return an empty map if format is incorrect
    }

    while (start < end) {
        size_t colonPos = str.find(':', start); // Find the position of ':'
        size_t keyStart = str.find('"', start) + 1; // Find the key start position
        size_t keyEnd = str.find('"', keyStart); // Find the key end position
        
        if (keyEnd == std::string::npos || colonPos == std::string::npos || keyEnd > colonPos) {
            break; // Exit if format is incorrect
        }

        std::string key = str.substr(keyStart, keyEnd - keyStart); // Get the key
        size_t valueStart = colonPos + 1; // Start position of value
        size_t valueEnd = str.find(',', valueStart); // Find the next ',' position
        
        if (valueEnd == std::string::npos) {
            valueEnd = end; // If no ',' found, set to the end
        }

        // Remove whitespace after ':' and before the starting quote of the value
        size_t valueQuoteStart = str.find('"', valueStart);
        size_t valueQuoteEnd = str.find('"', valueQuoteStart + 1); // Find the value end

        std::string value = str.substr(valueQuoteStart + 1, valueQuoteEnd - valueQuoteStart - 1); // Get value

        myMap[key] = value; // Add to the map
        start = valueEnd + 1; // Update the start position
    }

    return myMap; // Return the constructed map
}

std::vector<std::string> stringToVector(const std::string& str) {
    std::vector<std::string> result;
    std::string::size_type start = 0;
    std::string::size_type end = str.find(',');

    while (end != std::string::npos) {
        result.push_back(str.substr(start, end - start));
        start = end + 1;
        end = str.find(',', start);
    }
    result.push_back(str.substr(start));

    return result;
}

std::string vectorToString(const std::vector<std::string>& vec) {
    std::string result = "{";
    for (size_t i = 0; i < vec.size(); ++i) {
        result += "\"" + vec[i] + "\"";
        if (i < vec.size() - 1) {
            result += ", ";
        }
    }
    result += "}";
    return result;
}

// // splitString takes a string and a delimiter character and returns a ww::value::Array
// ww::value::Array splitString(const std::string& str, char delimiter) {
//     ww::value::Array result;
//     ww::value::Object model_map;
//     std::stringstream ss(str);
//     std::string item;

//     while (std::getline(ss, item, delimiter)) {
//         model_map.set_value(item.c_str(), ww::value::String("not used"));
//         result.append_value(model_map);
//     }

//     return result;
// }


std::vector<ww::types::StringArray> splitForTags(const std::string& str) {
    std::vector<ww::types::StringArray> result;
    std::stringstream ss(str);
    std::string item;

    while (std::getline(ss, item, ',')) {
        result.push_back('0');
    }

    return result;
}

std::string joinString(const std::vector<std::string>& vec, char delimiter) {
    std::string result;
    for (const auto& item : vec) {
        result += item + delimiter;
    }

    return result;
}